---
title: "RED CORAL Curation"
output: html_document
---


Libraries
```{r}
library(tidyverse)
library(pdftools)
library(jsonlite)
# Set working directory to pic-sure-metadata-curation/redcoral/
```

We get the following from redcoral:
```{r}
# csv data dictionary from redcap
raw_datadict <- read.csv('../input/CORAL data dictionary v2.16.csv')

pdf_datadict <- pdf_text("../input/Data Dictionary.pdf")

consolidated_doc <- pdf_text("../input/RED CORAL Study Documents_consolidated.pdf")

sas_file <- read.csv('../input/redcoral_decode_usable.csv')

```

Although the pdf_datadict appears to have ~1500 variables, the raw_datadict only contains 914. 
We will use the 914 variables in raw_datadict as a starting point.
We use the terminology "level 0", "level 1", etc. to avoid getting confused with "variable name", "section name", "table name".
Levels start at most specific (0) and become more general. 
```{r}
df <- data.frame('level_0' = raw_datadict$Variable...Field.Name,
                 'level_1' = raw_datadict$Field.Label, 
                 'level_2' = raw_datadict$Section.Header,
                 'level_3' = raw_datadict$Form.Name)

```

Let's strip the HTML from level 2 and level 1 and fill in the blanks. Here, we also get rid of the variables that are not included in the final dataframe ("notes")
```{r}
df <- df %>%
  mutate(level_2 = str_trim(str_replace_all(level_2, '<.*?>', ' ')),
         level_1 = str_trim(str_replace_all(level_1, '<.*?>', ' ')),
         level_2 = na_if(level_2, '')) %>%
         fill(level_2) %>%
  filter(!grepl('notes', level_0)) %>%
  filter(!is.na(level_2))
```

The free text found in the consolidated PDF for the 'broader categories' has been manually recorded.
Some of the previous descriptions of sub-headings of others. These are noted by the relationship column.
We are not sure which of our "levels" these categories correspond to.
```{r}
desc_consolidated <- read.csv('../input/cat_desc_from_consolidated.csv')
head(desc_consolidated)

```

In the consolidated PDF, 
If we look at our "level_3" variables, we see a similar pattern.
```{r}
table(df$level_3)

```
We will create another, broader level to account for the additional descriptions found in the consolidated PDF.
```{r}
define_level_4 <- function(x){
  ifelse(grepl('inclusion', x), 'INCLUSION',
    ifelse(grepl('baseline', x), 'BASELINE DATA COLLECTION',
           ifelse(grepl('daily', x), 'DAILY ASSESSMENT',
                  ifelse(grepl('summative', x), 'SUMATIVE/DISCHARGE DATA',
                         'PLACEHOLDER INSTRUMENTS'))))
}

df <- df %>% 
  mutate(level_4 = define_level_4(level_3))

```

Still, the "names" from the consolidated PDF do not perfectly match 'level_3' in the data dictionary. 
We manually created the mapping so that we can add the descriptions.
```{r}
level_3_mapping <- read.csv('../input/level_3_mapping.csv')
```

Let's rename our level 3 variables and merge in the descriptions for level 3 and level 4 variables.
```{r}
df2 <- df %>%
  left_join(level_3_mapping, by = c('level_3' = 'datadict_name')) %>%
  select(-level_3) %>%
  rename('level_3' = 'combined_pdf_name') %>%
  left_join(desc_consolidated %>% select(name, desc), by = c('level_3' = 'name')) %>%
  rename('level_3_desc' = 'desc') %>%
  left_join(desc_consolidated %>% select(name, desc), by = c('level_4' = 'name')) %>%
  rename('level_4_desc' = 'desc') %>%
  mutate('level_2_desc' = '', 
         'level_1_desc' = '', 
         'level_0_desc' = '') %>%
  relocate(level_0, level_0_desc,
           level_1, level_1_desc,
           level_2, level_2_desc,
           level_3, level_3_desc,
           level_4, level_4_desc) %>%
  mutate(level_1 = gsub('â€”', '-', level_1)) # remove strange characters from output

```


Let's merge our dataframe with the information provided through sas.
Sas provides us with the following information:
- some variable IDs and names which are not in data dictionary csv
- variable types
Our goal is that each variable ID will have a variable name which may come from the data dictionary csv or from sas.
This will be specified in the metadata.
```{r}
df3 <- full_join(df2, 
                 sas_file %>% select(NAME, TYPE, LABEL), 
                 by = c('level_0' = 'NAME')) %>%
  mutate(varname = ifelse(!is.na(level_1), level_1, LABEL))


```

Example json output 

{
  "var_name": "gender",
  "var_desc": "desc gender",
  "var_id": "gndr"
  "study_id":"phsXXX"
  "metadata": { 
    "encounter_name": "INCLUSION"
}

The main goal will be to create a nested JSON file.
First, we will add variable-level metadata information for each variable.
```{r}
# we don't know the type for all variables, subbing '99'

df4 <- df3 %>%
  mutate(TYPE = ifelse(is.na(TYPE), 99, TYPE)) %>%
  select(level_0, TYPE, varname) %>%
  rename('var_id' = 'level_0',
         'var_name' = 'varname',
         'var_type' = 'TYPE') 

for (r in c(1:nrow(df4))) {
  res_df <- df3[r,] %>%
    select(level_1, level_2, level_3, level_4, varname)  %>%
    rename('datadict_varname' = 'level_1',
           'sas_varname' = 'varname',
           'var_group' = 'level_2',
           'form_id' = 'level_3',
           'encounter_id' = 'level_4') 
  df4[r,'metadata'][[1]] <- list(res_df)
}
```

***Begin Emily edits***

```{r}
df5 <- df3 %>% 
  mutate(TYPE = ifelse(is.na(TYPE), 99, TYPE)) %>%
  select(level_2) %>%
  rename('var_group' = 'level_2') %>%
  filter(!is.na(var_group)) %>%
  unique()



vargroup_df <- data.frame('vargroup_name' = var_groups)

var_groups <- df3 %>% pull(level_2) %>% unique()

for (group in var_groups) {
  
  
  our_ids <- df3 %>% filter(level_2 == group) %>% pull(level_0)
  subdf3 <- df4 %>% filter(var_id %in% our_ids)
  vargroup_df[which(var_groups == group),'var_data'][[1]] <- list(subdf3)

}



forms <- df3 %>% pull(level_3) %>% unique()

for (form in )




my_json <- toJSON(vargroup_df, pretty=FALSE)

print(my_json)

```

```{r}
level_2_var_mapping <- df3 %>%
  select(level_0, level_2)
```

Note for Simran:
Tricky thing that I can't figure out - in the above example, the metadata of each row of the dataframe is associated with a single list. Below, we need to link a list of lists (the metadata for multiple variables) to a single form or var_group. This would be super easy to accomplish with a Python dictionary, but I tried to use a list of lists in R. It's only saving the first list in the big list, so I can't figure out how to proceed.


```{r}
for (r in c(1:nrow(df5))) {
 if (r == 2) {
   temp_group <- df5[r, 'var_group']
   temp_vars <- level_2_var_mapping %>%
     filter(level_2 == temp_group) %>%
     select(level_0)
   result <- c()
   temp_vars <- temp_vars[, 'level_0']
   for (var in temp_vars) {
     temp_var_data <- df4 %>%
       filter(var_id == var)
     result <- c(result, list(temp_var_data))
   }
   df5[r, 'var_info'][[1]] <- result
 } 
}
```


```{r}

my_json <- toJSON(df4, pretty=FALSE)

#write_json(my_json, 'test.json', pretty=FALSE) 
#Setting pretty=FALSE does not work with escape character problem
```

Using the `write_json` function outputs quotations with escape characters ("/"). This causes problems with the JSON file format. This can be dealt with by converting the JSON object into a string and writing this to a text file.

```{r}
test_string_json <- as.character(my_json) # Convert to character/string
fileConn <- file("../output/variable_level.json")
writeLines(test_string_json, fileConn)
close(fileConn)

# This works for writing a JSON file without the escape characters
```

```{r}

write.csv(df3, '../test_summary_df.csv', row.names = FALSE)
```

```{r}

```







